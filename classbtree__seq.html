<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>b-tree sequence: btree_seq&lt; T, L, M, A &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">b-tree sequence
   </div>
   <div id="projectbrief">sequence container optimized for inserting/deleting in random places</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classbtree__seq-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">btree_seq&lt; T, L, M, A &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The fast sequence container, which behaves like std::vector takes O(log(N)) to insert/delete elements.  
 <a href="classbtree__seq.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="btree__seq_8h_source.html">btree_seq.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq_1_1iterator__base.html">iterator_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator template for const_iterator and iterator.  <a href="classbtree__seq_1_1iterator__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aacabfb30eacb213d95f505e477308ad6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacabfb30eacb213d95f505e477308ad6"></a>
typedef A&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#aacabfb30eacb213d95f505e477308ad6">allocator_type</a></td></tr>
<tr class="memdesc:aacabfb30eacb213d95f505e477308ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The last template parameter, allocator. <br/></td></tr>
<tr class="separator:aacabfb30eacb213d95f505e477308ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2795ed69e57bfb546fedff03f0c53d18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2795ed69e57bfb546fedff03f0c53d18"></a>
typedef A::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a></td></tr>
<tr class="memdesc:a2795ed69e57bfb546fedff03f0c53d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type, T (the first template parameter). <br/></td></tr>
<tr class="separator:a2795ed69e57bfb546fedff03f0c53d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b3f48ea01641b185a7afb822a78c2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56b3f48ea01641b185a7afb822a78c2f"></a>
typedef A::reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a56b3f48ea01641b185a7afb822a78c2f">reference</a></td></tr>
<tr class="memdesc:a56b3f48ea01641b185a7afb822a78c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference type, T&amp;. <br/></td></tr>
<tr class="separator:a56b3f48ea01641b185a7afb822a78c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545810e07ddf342e97b8584eab786ae5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a545810e07ddf342e97b8584eab786ae5"></a>
typedef A::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a545810e07ddf342e97b8584eab786ae5">const_reference</a></td></tr>
<tr class="memdesc:a545810e07ddf342e97b8584eab786ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant reference type, const T&amp;. <br/></td></tr>
<tr class="separator:a545810e07ddf342e97b8584eab786ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b6c2ff5cd78d5c8d308de4fe5d5a97"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48b6c2ff5cd78d5c8d308de4fe5d5a97"></a>
typedef A::pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a48b6c2ff5cd78d5c8d308de4fe5d5a97">pointer</a></td></tr>
<tr class="memdesc:a48b6c2ff5cd78d5c8d308de4fe5d5a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type, T*. <br/></td></tr>
<tr class="separator:a48b6c2ff5cd78d5c8d308de4fe5d5a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2829c581c5b59876c4b905a1ce0cae3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2829c581c5b59876c4b905a1ce0cae3"></a>
typedef A::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#ab2829c581c5b59876c4b905a1ce0cae3">const_pointer</a></td></tr>
<tr class="memdesc:ab2829c581c5b59876c4b905a1ce0cae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant pointer type, const T*. <br/></td></tr>
<tr class="separator:ab2829c581c5b59876c4b905a1ce0cae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5483ae7c750d2e6391e5fec12e4f67e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5483ae7c750d2e6391e5fec12e4f67e"></a>
typedef A::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a></td></tr>
<tr class="memdesc:ac5483ae7c750d2e6391e5fec12e4f67e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type, size_t (unsigned int). <br/></td></tr>
<tr class="separator:ac5483ae7c750d2e6391e5fec12e4f67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace11c619761a45a98fd10827f9ce9a4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace11c619761a45a98fd10827f9ce9a4f"></a>
typedef A::difference_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#ace11c619761a45a98fd10827f9ce9a4f">difference_type</a></td></tr>
<tr class="memdesc:ace11c619761a45a98fd10827f9ce9a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type, ptr_diff_t (int). <br/></td></tr>
<tr class="separator:ace11c619761a45a98fd10827f9ce9a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28bce8b2ed9a16e1691af535777cc37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad28bce8b2ed9a16e1691af535777cc37"></a>
typedef A::difference_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#ad28bce8b2ed9a16e1691af535777cc37">diff_type</a></td></tr>
<tr class="memdesc:ad28bce8b2ed9a16e1691af535777cc37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type, ptr_diff_t (int). <br/></td></tr>
<tr class="separator:ad28bce8b2ed9a16e1691af535777cc37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a13523f3cb23d63b45b2a9439bbc64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92a13523f3cb23d63b45b2a9439bbc64"></a>
typedef <a class="el" href="classbtree__seq_1_1iterator__base.html">iterator_base</a>&lt; const T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a></td></tr>
<tr class="memdesc:a92a13523f3cb23d63b45b2a9439bbc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant forward random-access iterator. <br/></td></tr>
<tr class="separator:a92a13523f3cb23d63b45b2a9439bbc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f5b004a113fda8832babbac5215871"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2f5b004a113fda8832babbac5215871"></a>
typedef <a class="el" href="classbtree__seq_1_1iterator__base.html">iterator_base</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#ac2f5b004a113fda8832babbac5215871">iterator</a></td></tr>
<tr class="memdesc:ac2f5b004a113fda8832babbac5215871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifying forward random-access iterator. <br/></td></tr>
<tr class="separator:ac2f5b004a113fda8832babbac5215871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a48111ade15f99ba6de79c6def32372"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a48111ade15f99ba6de79c6def32372"></a>
typedef std::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a3a48111ade15f99ba6de79c6def32372">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a3a48111ade15f99ba6de79c6def32372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant reverse random-access iterator. <br/></td></tr>
<tr class="separator:a3a48111ade15f99ba6de79c6def32372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112f455474f3f89b194a473a8895eff3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a112f455474f3f89b194a473a8895eff3"></a>
typedef std::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="classbtree__seq.html#ac2f5b004a113fda8832babbac5215871">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a112f455474f3f89b194a473a8895eff3">reverse_iterator</a></td></tr>
<tr class="memdesc:a112f455474f3f89b194a473a8895eff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifying reverse random-access iterator. <br/></td></tr>
<tr class="separator:a112f455474f3f89b194a473a8895eff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae967878d371222a4f9ade09a6f219ed7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#ae967878d371222a4f9ade09a6f219ed7">btree_seq</a> (const <a class="el" href="classbtree__seq.html#aacabfb30eacb213d95f505e477308ad6">allocator_type</a> &amp;alloc=<a class="el" href="classbtree__seq.html#aacabfb30eacb213d95f505e477308ad6">allocator_type</a>())</td></tr>
<tr class="memdesc:ae967878d371222a4f9ade09a6f219ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty container constructor.  <a href="#ae967878d371222a4f9ade09a6f219ed7">More...</a><br/></td></tr>
<tr class="separator:ae967878d371222a4f9ade09a6f219ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf681c6f509bdf7ca1045797b77f9875"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#abf681c6f509bdf7ca1045797b77f9875">btree_seq</a> (const <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt; &amp;that)</td></tr>
<tr class="memdesc:abf681c6f509bdf7ca1045797b77f9875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#abf681c6f509bdf7ca1045797b77f9875">More...</a><br/></td></tr>
<tr class="separator:abf681c6f509bdf7ca1045797b77f9875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa778862dbb879f8d7ca5fa0a41b0d60e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#aa778862dbb879f8d7ca5fa0a41b0d60e">btree_seq</a> (<a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a> n, const <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &amp;val, const <a class="el" href="classbtree__seq.html#aacabfb30eacb213d95f505e477308ad6">allocator_type</a> &amp;alloc=<a class="el" href="classbtree__seq.html#aacabfb30eacb213d95f505e477308ad6">allocator_type</a>())</td></tr>
<tr class="memdesc:aa778862dbb879f8d7ca5fa0a41b0d60e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill constructor.  <a href="#aa778862dbb879f8d7ca5fa0a41b0d60e">More...</a><br/></td></tr>
<tr class="separator:aa778862dbb879f8d7ca5fa0a41b0d60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3e7278bb146819587794a2e4014f7e"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:aad3e7278bb146819587794a2e4014f7e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#aad3e7278bb146819587794a2e4014f7e">btree_seq</a> (Iterator first, Iterator last, const <a class="el" href="classbtree__seq.html#aacabfb30eacb213d95f505e477308ad6">allocator_type</a> &amp;alloc=<a class="el" href="classbtree__seq.html#aacabfb30eacb213d95f505e477308ad6">allocator_type</a>())</td></tr>
<tr class="memdesc:aad3e7278bb146819587794a2e4014f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range constructor.  <a href="#aad3e7278bb146819587794a2e4014f7e">More...</a><br/></td></tr>
<tr class="separator:aad3e7278bb146819587794a2e4014f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb4e7d5b31301728c71cdc33eccf746"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#aadb4e7d5b31301728c71cdc33eccf746">btree_seq</a> (<a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt; &amp;&amp;that, const <a class="el" href="classbtree__seq.html#aacabfb30eacb213d95f505e477308ad6">allocator_type</a> &amp;alloc=<a class="el" href="classbtree__seq.html#aacabfb30eacb213d95f505e477308ad6">allocator_type</a>())</td></tr>
<tr class="memdesc:aadb4e7d5b31301728c71cdc33eccf746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor (C++11)  <a href="#aadb4e7d5b31301728c71cdc33eccf746">More...</a><br/></td></tr>
<tr class="separator:aadb4e7d5b31301728c71cdc33eccf746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4a61a64d5b3c9fae883ea8d6fb4492"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a1e4a61a64d5b3c9fae883ea8d6fb4492">btree_seq</a> (std::initializer_list&lt; <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &gt; il, const <a class="el" href="classbtree__seq.html#aacabfb30eacb213d95f505e477308ad6">allocator_type</a> &amp;alloc=<a class="el" href="classbtree__seq.html#aacabfb30eacb213d95f505e477308ad6">allocator_type</a>())</td></tr>
<tr class="memdesc:a1e4a61a64d5b3c9fae883ea8d6fb4492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list constructor (C++11)  <a href="#a1e4a61a64d5b3c9fae883ea8d6fb4492">More...</a><br/></td></tr>
<tr class="separator:a1e4a61a64d5b3c9fae883ea8d6fb4492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac566a0c4104292b7e9743aef345961a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#aac566a0c4104292b7e9743aef345961a">~btree_seq</a> ()</td></tr>
<tr class="memdesc:aac566a0c4104292b7e9743aef345961a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#aac566a0c4104292b7e9743aef345961a">More...</a><br/></td></tr>
<tr class="separator:aac566a0c4104292b7e9743aef345961a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr class="memitem:a2cbaddcbced2e577422a3bcc961c7809"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a2cbaddcbced2e577422a3bcc961c7809">begin</a> () const </td></tr>
<tr class="memdesc:a2cbaddcbced2e577422a3bcc961c7809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return constant iterator to beginning.  <a href="#a2cbaddcbced2e577422a3bcc961c7809">More...</a><br/></td></tr>
<tr class="separator:a2cbaddcbced2e577422a3bcc961c7809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7dcb91cb32f14a8a15cf4954d0b8ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a4a7dcb91cb32f14a8a15cf4954d0b8ac">end</a> () const </td></tr>
<tr class="memdesc:a4a7dcb91cb32f14a8a15cf4954d0b8ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return constant iterator to end.  <a href="#a4a7dcb91cb32f14a8a15cf4954d0b8ac">More...</a><br/></td></tr>
<tr class="separator:a4a7dcb91cb32f14a8a15cf4954d0b8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3460dd0210953edc353d4238ded53b4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a3460dd0210953edc353d4238ded53b4e">cbegin</a> () const </td></tr>
<tr class="memdesc:a3460dd0210953edc353d4238ded53b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return constant iterator to beginning.  <a href="#a3460dd0210953edc353d4238ded53b4e">More...</a><br/></td></tr>
<tr class="separator:a3460dd0210953edc353d4238ded53b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec771bf973f3b9bff318bbb17f55ee2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#adec771bf973f3b9bff318bbb17f55ee2">cend</a> () const </td></tr>
<tr class="memdesc:adec771bf973f3b9bff318bbb17f55ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return constant iterator to end.  <a href="#adec771bf973f3b9bff318bbb17f55ee2">More...</a><br/></td></tr>
<tr class="separator:adec771bf973f3b9bff318bbb17f55ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcaa2fdbe4894061cf565c6fa49d9f7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#ac2f5b004a113fda8832babbac5215871">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#abcaa2fdbe4894061cf565c6fa49d9f7f">begin</a> ()</td></tr>
<tr class="memdesc:abcaa2fdbe4894061cf565c6fa49d9f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to beginning.  <a href="#abcaa2fdbe4894061cf565c6fa49d9f7f">More...</a><br/></td></tr>
<tr class="separator:abcaa2fdbe4894061cf565c6fa49d9f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6364a7d2560e00253f860ffd9631ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#ac2f5b004a113fda8832babbac5215871">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#adf6364a7d2560e00253f860ffd9631ba">end</a> ()</td></tr>
<tr class="memdesc:adf6364a7d2560e00253f860ffd9631ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return constant iterator to end.  <a href="#adf6364a7d2560e00253f860ffd9631ba">More...</a><br/></td></tr>
<tr class="separator:adf6364a7d2560e00253f860ffd9631ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97d9590209db423c1894ede620c02b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#a3a48111ade15f99ba6de79c6def32372">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#ac97d9590209db423c1894ede620c02b2">rbegin</a> () const </td></tr>
<tr class="memdesc:ac97d9590209db423c1894ede620c02b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return constant reverse iterator to reverse beginning.  <a href="#ac97d9590209db423c1894ede620c02b2">More...</a><br/></td></tr>
<tr class="separator:ac97d9590209db423c1894ede620c02b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6b6aeff69677b6284056787ef9eb8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#a3a48111ade15f99ba6de79c6def32372">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#afd6b6aeff69677b6284056787ef9eb8a">rend</a> () const </td></tr>
<tr class="memdesc:afd6b6aeff69677b6284056787ef9eb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return constant reverse iterator to reverse end.  <a href="#afd6b6aeff69677b6284056787ef9eb8a">More...</a><br/></td></tr>
<tr class="separator:afd6b6aeff69677b6284056787ef9eb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f43e0675ba88f9837e94098c3057fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#a3a48111ade15f99ba6de79c6def32372">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#aa6f43e0675ba88f9837e94098c3057fb">crbegin</a> () const </td></tr>
<tr class="memdesc:aa6f43e0675ba88f9837e94098c3057fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return constant reverse iterator to reverse beginning.  <a href="#aa6f43e0675ba88f9837e94098c3057fb">More...</a><br/></td></tr>
<tr class="separator:aa6f43e0675ba88f9837e94098c3057fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25094ad31605b20365bd5de66f6d6738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#a3a48111ade15f99ba6de79c6def32372">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a25094ad31605b20365bd5de66f6d6738">crend</a> () const </td></tr>
<tr class="memdesc:a25094ad31605b20365bd5de66f6d6738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return constant reverse iterator to reverse end.  <a href="#a25094ad31605b20365bd5de66f6d6738">More...</a><br/></td></tr>
<tr class="separator:a25094ad31605b20365bd5de66f6d6738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ade4d8fb4dc24794fc8ca0a6b997941"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#a112f455474f3f89b194a473a8895eff3">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a3ade4d8fb4dc24794fc8ca0a6b997941">rbegin</a> ()</td></tr>
<tr class="memdesc:a3ade4d8fb4dc24794fc8ca0a6b997941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return reverse iterator to reverse beginning.  <a href="#a3ade4d8fb4dc24794fc8ca0a6b997941">More...</a><br/></td></tr>
<tr class="separator:a3ade4d8fb4dc24794fc8ca0a6b997941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2175c21e53e7ec96bf149eefd601c8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#a112f455474f3f89b194a473a8895eff3">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#ac2175c21e53e7ec96bf149eefd601c8d">rend</a> ()</td></tr>
<tr class="memdesc:ac2175c21e53e7ec96bf149eefd601c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return reverse iterator to reverse end.  <a href="#ac2175c21e53e7ec96bf149eefd601c8d">More...</a><br/></td></tr>
<tr class="separator:ac2175c21e53e7ec96bf149eefd601c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b13b712a26d216a5392ae16289d073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#ac2f5b004a113fda8832babbac5215871">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#ad0b13b712a26d216a5392ae16289d073">iterator_at</a> (<a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a> pos)</td></tr>
<tr class="memdesc:ad0b13b712a26d216a5392ae16289d073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to a given index.  <a href="#ad0b13b712a26d216a5392ae16289d073">More...</a><br/></td></tr>
<tr class="separator:ad0b13b712a26d216a5392ae16289d073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ccc92fa4872337b82d0953e0342111"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a00ccc92fa4872337b82d0953e0342111">citerator_at</a> (<a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a> pos) const </td></tr>
<tr class="memdesc:a00ccc92fa4872337b82d0953e0342111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return constant iterator to a given index.  <a href="#a00ccc92fa4872337b82d0953e0342111">More...</a><br/></td></tr>
<tr class="separator:a00ccc92fa4872337b82d0953e0342111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Access of the contents </p>
</div></td></tr>
<tr class="memitem:ac4fc5026ae6f80c7e6f5d2a4251638e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#a56b3f48ea01641b185a7afb822a78c2f">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#ac4fc5026ae6f80c7e6f5d2a4251638e5">operator[]</a> (<a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a> pos)</td></tr>
<tr class="memdesc:ac4fc5026ae6f80c7e6f5d2a4251638e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to element.  <a href="#ac4fc5026ae6f80c7e6f5d2a4251638e5">More...</a><br/></td></tr>
<tr class="separator:ac4fc5026ae6f80c7e6f5d2a4251638e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953676ab63917fe656a55946d52569e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#a545810e07ddf342e97b8584eab786ae5">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a953676ab63917fe656a55946d52569e1">operator[]</a> (<a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a> pos) const </td></tr>
<tr class="memdesc:a953676ab63917fe656a55946d52569e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant access to element.  <a href="#a953676ab63917fe656a55946d52569e1">More...</a><br/></td></tr>
<tr class="separator:a953676ab63917fe656a55946d52569e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7718a31872ee32e50c6bc27bafc70c7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7718a31872ee32e50c6bc27bafc70c7b"></a>
<a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a7718a31872ee32e50c6bc27bafc70c7b">size</a> () const </td></tr>
<tr class="memdesc:a7718a31872ee32e50c6bc27bafc70c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements in container. <br/></td></tr>
<tr class="separator:a7718a31872ee32e50c6bc27bafc70c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7eae08cf84bfdc7171c54b86b7563d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#a56b3f48ea01641b185a7afb822a78c2f">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a1b7eae08cf84bfdc7171c54b86b7563d">at</a> (<a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a> pos)</td></tr>
<tr class="memdesc:a1b7eae08cf84bfdc7171c54b86b7563d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to element with range check.  <a href="#a1b7eae08cf84bfdc7171c54b86b7563d">More...</a><br/></td></tr>
<tr class="separator:a1b7eae08cf84bfdc7171c54b86b7563d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389fdef127cc151dd883193f977d74f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#a545810e07ddf342e97b8584eab786ae5">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a389fdef127cc151dd883193f977d74f1">at</a> (<a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a> pos) const </td></tr>
<tr class="memdesc:a389fdef127cc151dd883193f977d74f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant access to element with range check.  <a href="#a389fdef127cc151dd883193f977d74f1">More...</a><br/></td></tr>
<tr class="separator:a389fdef127cc151dd883193f977d74f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffe3f8e12e9910dd5d505d2220cfc68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#a56b3f48ea01641b185a7afb822a78c2f">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a0ffe3f8e12e9910dd5d505d2220cfc68">front</a> ()</td></tr>
<tr class="memdesc:a0ffe3f8e12e9910dd5d505d2220cfc68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element.  <a href="#a0ffe3f8e12e9910dd5d505d2220cfc68">More...</a><br/></td></tr>
<tr class="separator:a0ffe3f8e12e9910dd5d505d2220cfc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada29272e15728d63e8f0ae7b3b08f6f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#a545810e07ddf342e97b8584eab786ae5">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#ada29272e15728d63e8f0ae7b3b08f6f5">front</a> () const </td></tr>
<tr class="memdesc:ada29272e15728d63e8f0ae7b3b08f6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constnt reference to the first element.  <a href="#ada29272e15728d63e8f0ae7b3b08f6f5">More...</a><br/></td></tr>
<tr class="separator:ada29272e15728d63e8f0ae7b3b08f6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf48b8c30757da3a8634c3696aedec3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#a56b3f48ea01641b185a7afb822a78c2f">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#acf48b8c30757da3a8634c3696aedec3a">back</a> ()</td></tr>
<tr class="memdesc:acf48b8c30757da3a8634c3696aedec3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element.  <a href="#acf48b8c30757da3a8634c3696aedec3a">More...</a><br/></td></tr>
<tr class="separator:acf48b8c30757da3a8634c3696aedec3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cda219eca79d5b1697f58ef68acafb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#a545810e07ddf342e97b8584eab786ae5">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a2cda219eca79d5b1697f58ef68acafb7">back</a> () const </td></tr>
<tr class="memdesc:a2cda219eca79d5b1697f58ef68acafb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the last element.  <a href="#a2cda219eca79d5b1697f58ef68acafb7">More...</a><br/></td></tr>
<tr class="separator:a2cda219eca79d5b1697f58ef68acafb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e9e35d70ab9770f34aad7cea430923"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3e9e35d70ab9770f34aad7cea430923"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#af3e9e35d70ab9770f34aad7cea430923">empty</a> () const </td></tr>
<tr class="memdesc:af3e9e35d70ab9770f34aad7cea430923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the container contains no elements. <br/></td></tr>
<tr class="separator:af3e9e35d70ab9770f34aad7cea430923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3386347d804526a1e8e5b83dbf7bb234"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a3386347d804526a1e8e5b83dbf7bb234"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a3386347d804526a1e8e5b83dbf7bb234">visit</a> (<a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a> first, <a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a> last, V &amp;v)</td></tr>
<tr class="memdesc:a3386347d804526a1e8e5b83dbf7bb234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential search/modify operation on the range.  <a href="#a3386347d804526a1e8e5b83dbf7bb234">More...</a><br/></td></tr>
<tr class="separator:a3386347d804526a1e8e5b83dbf7bb234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modifying certain elements of the sequence</div></td></tr>
<tr class="memitem:ac646ad8ff84bdd504f4650e9cc365724"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#ac646ad8ff84bdd504f4650e9cc365724">insert</a> (<a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a> pos, const <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:ac646ad8ff84bdd504f4650e9cc365724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Native function for inserting a single element.  <a href="#ac646ad8ff84bdd504f4650e9cc365724">More...</a><br/></td></tr>
<tr class="separator:ac646ad8ff84bdd504f4650e9cc365724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb71f46140eb692007294fecea3ab65"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:adfb71f46140eb692007294fecea3ab65"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#adfb71f46140eb692007294fecea3ab65">insert</a> (<a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a> pos, InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:adfb71f46140eb692007294fecea3ab65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Native function for inserting a range of elements.  <a href="#adfb71f46140eb692007294fecea3ab65">More...</a><br/></td></tr>
<tr class="separator:adfb71f46140eb692007294fecea3ab65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01165cb27da14f4a8108f0f458c255d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#ac2f5b004a113fda8832babbac5215871">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#af01165cb27da14f4a8108f0f458c255d">insert</a> (<a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a> pos, const <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:af01165cb27da14f4a8108f0f458c255d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compatible function for inserting the single element.  <a href="#af01165cb27da14f4a8108f0f458c255d">More...</a><br/></td></tr>
<tr class="separator:af01165cb27da14f4a8108f0f458c255d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441c12c08c25c9b90c064607aea8ea60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#ac2f5b004a113fda8832babbac5215871">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a441c12c08c25c9b90c064607aea8ea60">insert</a> (<a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a> pos, <a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a> n, const <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a441c12c08c25c9b90c064607aea8ea60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compatible function for inserting n copies of an element.  <a href="#a441c12c08c25c9b90c064607aea8ea60">More...</a><br/></td></tr>
<tr class="separator:a441c12c08c25c9b90c064607aea8ea60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ba52ae106966fe8244efb41f573279"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a74ba52ae106966fe8244efb41f573279"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#ac2f5b004a113fda8832babbac5215871">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a74ba52ae106966fe8244efb41f573279">insert</a> (<a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a> pos, InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a74ba52ae106966fe8244efb41f573279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compatible function for inserting a range of elements.  <a href="#a74ba52ae106966fe8244efb41f573279">More...</a><br/></td></tr>
<tr class="separator:a74ba52ae106966fe8244efb41f573279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04cc444213c48f2bb2da568b287d869"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#af04cc444213c48f2bb2da568b287d869">insert</a> (<a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a> pos, <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:af04cc444213c48f2bb2da568b287d869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Native inserting of rvalue (C++11)  <a href="#af04cc444213c48f2bb2da568b287d869">More...</a><br/></td></tr>
<tr class="separator:af04cc444213c48f2bb2da568b287d869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606ee33665104f91de1d74be4d68a848"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#ac2f5b004a113fda8832babbac5215871">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a606ee33665104f91de1d74be4d68a848">insert</a> (<a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a> pos, <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:a606ee33665104f91de1d74be4d68a848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compatible insertion of rvalue (C++11)  <a href="#a606ee33665104f91de1d74be4d68a848">More...</a><br/></td></tr>
<tr class="separator:a606ee33665104f91de1d74be4d68a848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643109fc4a01c8a6524f3a274980b6d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a643109fc4a01c8a6524f3a274980b6d0">insert</a> (<a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a> pos, std::initializer_list&lt; <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &gt; il)</td></tr>
<tr class="memdesc:a643109fc4a01c8a6524f3a274980b6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Native inserting of elements using initializer_list (C++11)  <a href="#a643109fc4a01c8a6524f3a274980b6d0">More...</a><br/></td></tr>
<tr class="separator:a643109fc4a01c8a6524f3a274980b6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99eb3c396aa2246d62fd65d83f8979a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#ac2f5b004a113fda8832babbac5215871">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a99eb3c396aa2246d62fd65d83f8979a1">insert</a> (<a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a> pos, std::initializer_list&lt; <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &gt; il)</td></tr>
<tr class="memdesc:a99eb3c396aa2246d62fd65d83f8979a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compatible inserting of elements using initializer_list (C++11)  <a href="#a99eb3c396aa2246d62fd65d83f8979a1">More...</a><br/></td></tr>
<tr class="separator:a99eb3c396aa2246d62fd65d83f8979a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239c4dd4465685efc9661cc932f8c5d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a239c4dd4465685efc9661cc932f8c5d7">fill</a> (<a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a> pos, <a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a> repetition, const <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a239c4dd4465685efc9661cc932f8c5d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Native function for inserting n copies of an element.  <a href="#a239c4dd4465685efc9661cc932f8c5d7">More...</a><br/></td></tr>
<tr class="separator:a239c4dd4465685efc9661cc932f8c5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ca414d95bfdfe1991e4d233a1eab5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#ae0ca414d95bfdfe1991e4d233a1eab5b">resize</a> (<a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a> n, const <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &amp;val=<a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a>())</td></tr>
<tr class="memdesc:ae0ca414d95bfdfe1991e4d233a1eab5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize container so that it contains n elements.  <a href="#ae0ca414d95bfdfe1991e4d233a1eab5b">More...</a><br/></td></tr>
<tr class="separator:ae0ca414d95bfdfe1991e4d233a1eab5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f93ea67380237bf705c78bcf2cae98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#ad1f93ea67380237bf705c78bcf2cae98">erase</a> (<a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a> first, <a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a> last)</td></tr>
<tr class="memdesc:ad1f93ea67380237bf705c78bcf2cae98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Native function for erasing elements.  <a href="#ad1f93ea67380237bf705c78bcf2cae98">More...</a><br/></td></tr>
<tr class="separator:ad1f93ea67380237bf705c78bcf2cae98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9c10fd4ec46c7f13939b7d9cdd10f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#ac2f5b004a113fda8832babbac5215871">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#aea9c10fd4ec46c7f13939b7d9cdd10f3">erase</a> (<a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a> pos)</td></tr>
<tr class="memdesc:aea9c10fd4ec46c7f13939b7d9cdd10f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compatible function for erasing one element.  <a href="#aea9c10fd4ec46c7f13939b7d9cdd10f3">More...</a><br/></td></tr>
<tr class="separator:aea9c10fd4ec46c7f13939b7d9cdd10f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6cb6609f7fd9866d267ec8bbaa7b5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#ac2f5b004a113fda8832babbac5215871">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a0f6cb6609f7fd9866d267ec8bbaa7b5a">erase</a> (<a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a> first, <a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a> last)</td></tr>
<tr class="memdesc:a0f6cb6609f7fd9866d267ec8bbaa7b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compatible function for erasing elements.  <a href="#a0f6cb6609f7fd9866d267ec8bbaa7b5a">More...</a><br/></td></tr>
<tr class="separator:a0f6cb6609f7fd9866d267ec8bbaa7b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129e0dfc0071f0856043cd0c63e0a31e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a129e0dfc0071f0856043cd0c63e0a31e">push_back</a> (const <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a129e0dfc0071f0856043cd0c63e0a31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds element to the end of the sequence.  <a href="#a129e0dfc0071f0856043cd0c63e0a31e">More...</a><br/></td></tr>
<tr class="separator:a129e0dfc0071f0856043cd0c63e0a31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198c1d96d898ef3e7e9704e07c6400bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a198c1d96d898ef3e7e9704e07c6400bd">push_front</a> (const <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a198c1d96d898ef3e7e9704e07c6400bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds element to the beginning of the sequence.  <a href="#a198c1d96d898ef3e7e9704e07c6400bd">More...</a><br/></td></tr>
<tr class="separator:a198c1d96d898ef3e7e9704e07c6400bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab6029eac58ff440c34507eeb83788a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a8ab6029eac58ff440c34507eeb83788a">pop_back</a> ()</td></tr>
<tr class="memdesc:a8ab6029eac58ff440c34507eeb83788a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element.  <a href="#a8ab6029eac58ff440c34507eeb83788a">More...</a><br/></td></tr>
<tr class="separator:a8ab6029eac58ff440c34507eeb83788a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848a059b91c3099306e72bbafcb44e20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a848a059b91c3099306e72bbafcb44e20">pop_front</a> ()</td></tr>
<tr class="memdesc:a848a059b91c3099306e72bbafcb44e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first element.  <a href="#a848a059b91c3099306e72bbafcb44e20">More...</a><br/></td></tr>
<tr class="separator:a848a059b91c3099306e72bbafcb44e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab2c8a4979ee2da845a7283567fd9fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adab2c8a4979ee2da845a7283567fd9fb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#adab2c8a4979ee2da845a7283567fd9fb">push_back</a> (<a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:adab2c8a4979ee2da845a7283567fd9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the element at the end of container and leaves val with undefined state. (C++11) <br/></td></tr>
<tr class="separator:adab2c8a4979ee2da845a7283567fd9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2a33c5ba690d8b40c1cbe0db03a824"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf2a33c5ba690d8b40c1cbe0db03a824"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#acf2a33c5ba690d8b40c1cbe0db03a824">push_front</a> (<a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:acf2a33c5ba690d8b40c1cbe0db03a824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the element at the beginning of container and leaves val with undefined state. (C++11) <br/></td></tr>
<tr class="separator:acf2a33c5ba690d8b40c1cbe0db03a824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9acc9d2f9612ae243046ffeebe9e4271"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a9acc9d2f9612ae243046ffeebe9e4271"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a9acc9d2f9612ae243046ffeebe9e4271">emplace</a> (<a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a> pos, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a9acc9d2f9612ae243046ffeebe9e4271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Native emplace function (C++11)  <a href="#a9acc9d2f9612ae243046ffeebe9e4271">More...</a><br/></td></tr>
<tr class="separator:a9acc9d2f9612ae243046ffeebe9e4271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f95eb47da57937f68d459481ba69a27"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a4f95eb47da57937f68d459481ba69a27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html#ac2f5b004a113fda8832babbac5215871">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a4f95eb47da57937f68d459481ba69a27">emplace</a> (<a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a> pos, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a4f95eb47da57937f68d459481ba69a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an element at the given position (C++11)  <a href="#a4f95eb47da57937f68d459481ba69a27">More...</a><br/></td></tr>
<tr class="separator:a4f95eb47da57937f68d459481ba69a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a25872f20f5c247ec0249d8c6c2e9d8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3a25872f20f5c247ec0249d8c6c2e9d8"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a3a25872f20f5c247ec0249d8c6c2e9d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a3a25872f20f5c247ec0249d8c6c2e9d8">emplace_front</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a3a25872f20f5c247ec0249d8c6c2e9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an element at the beginning of the container and passes args to its constructor. (C++11) <br/></td></tr>
<tr class="separator:a3a25872f20f5c247ec0249d8c6c2e9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2a066c44a03d906b6cbbaf76aaa733"><td class="memTemplParams" colspan="2"><a class="anchor" id="afd2a066c44a03d906b6cbbaf76aaa733"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:afd2a066c44a03d906b6cbbaf76aaa733"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#afd2a066c44a03d906b6cbbaf76aaa733">emplace_back</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:afd2a066c44a03d906b6cbbaf76aaa733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an element at the end of the container and passes args to its constructor. (C++11) <br/></td></tr>
<tr class="separator:afd2a066c44a03d906b6cbbaf76aaa733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modifying the whole contents of the sequence</div></td></tr>
<tr class="memitem:a77f2e899303623fa3ee7cabeb685664d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html">btree_seq</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a77f2e899303623fa3ee7cabeb685664d">operator=</a> (const <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt; &amp;that)</td></tr>
<tr class="memdesc:a77f2e899303623fa3ee7cabeb685664d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign content.  <a href="#a77f2e899303623fa3ee7cabeb685664d">More...</a><br/></td></tr>
<tr class="separator:a77f2e899303623fa3ee7cabeb685664d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619807093d367c8b0597929bfd4c3ba3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a619807093d367c8b0597929bfd4c3ba3">swap</a> (<a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt; &amp;that)</td></tr>
<tr class="memdesc:a619807093d367c8b0597929bfd4c3ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps contents of two containers.  <a href="#a619807093d367c8b0597929bfd4c3ba3">More...</a><br/></td></tr>
<tr class="separator:a619807093d367c8b0597929bfd4c3ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4825047ccfa73bf0463adf140686572a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a4825047ccfa73bf0463adf140686572a">clear</a> ()</td></tr>
<tr class="memdesc:a4825047ccfa73bf0463adf140686572a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all contents of the container.  <a href="#a4825047ccfa73bf0463adf140686572a">More...</a><br/></td></tr>
<tr class="separator:a4825047ccfa73bf0463adf140686572a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9adbb4b43417a3e99de04e7a0fd18b71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a9adbb4b43417a3e99de04e7a0fd18b71">assign</a> (<a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a> n, const <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a9adbb4b43417a3e99de04e7a0fd18b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the whole contents with n copies of val.  <a href="#a9adbb4b43417a3e99de04e7a0fd18b71">More...</a><br/></td></tr>
<tr class="separator:a9adbb4b43417a3e99de04e7a0fd18b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca3a97168136ca7a2bbe6b72928a41d"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:aeca3a97168136ca7a2bbe6b72928a41d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#aeca3a97168136ca7a2bbe6b72928a41d">assign</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:aeca3a97168136ca7a2bbe6b72928a41d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the whole contents with a range.  <a href="#aeca3a97168136ca7a2bbe6b72928a41d">More...</a><br/></td></tr>
<tr class="separator:aeca3a97168136ca7a2bbe6b72928a41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920653703ae3ba03593844b5098cc2ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a920653703ae3ba03593844b5098cc2ba">concatenate_right</a> (<a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt; &amp;that)</td></tr>
<tr class="memdesc:a920653703ae3ba03593844b5098cc2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast concatenate two sequences (that sequence to the right).  <a href="#a920653703ae3ba03593844b5098cc2ba">More...</a><br/></td></tr>
<tr class="separator:a920653703ae3ba03593844b5098cc2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552b7737567dc43f66ec8a84acdf98b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a552b7737567dc43f66ec8a84acdf98b9">concatenate_left</a> (<a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt; &amp;that)</td></tr>
<tr class="memdesc:a552b7737567dc43f66ec8a84acdf98b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast concatenate two sequences (that sequence to the left).  <a href="#a552b7737567dc43f66ec8a84acdf98b9">More...</a><br/></td></tr>
<tr class="separator:a552b7737567dc43f66ec8a84acdf98b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b2ff28f3722f18b09b8d0e3852efc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a93b2ff28f3722f18b09b8d0e3852efc7">split_right</a> (<a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt; &amp;that, <a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a> pos)</td></tr>
<tr class="memdesc:a93b2ff28f3722f18b09b8d0e3852efc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast split, leaving right piece in that container.  <a href="#a93b2ff28f3722f18b09b8d0e3852efc7">More...</a><br/></td></tr>
<tr class="separator:a93b2ff28f3722f18b09b8d0e3852efc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0100fa5afe5ff6d475cb31bfef5b63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#abb0100fa5afe5ff6d475cb31bfef5b63">split_left</a> (<a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt; &amp;that, <a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a> pos)</td></tr>
<tr class="memdesc:abb0100fa5afe5ff6d475cb31bfef5b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast split, leaving left piece in that container.  <a href="#abb0100fa5afe5ff6d475cb31bfef5b63">More...</a><br/></td></tr>
<tr class="separator:abb0100fa5afe5ff6d475cb31bfef5b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8a35aee8a011f4e699887210e364f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html">btree_seq</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#adb8a35aee8a011f4e699887210e364f0">operator=</a> (<a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt; &amp;&amp;that)</td></tr>
<tr class="memdesc:adb8a35aee8a011f4e699887210e364f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move operator= (C++11)  <a href="#adb8a35aee8a011f4e699887210e364f0">More...</a><br/></td></tr>
<tr class="separator:adb8a35aee8a011f4e699887210e364f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab777be375a9d249931535938f5fd3501"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtree__seq.html">btree_seq</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#ab777be375a9d249931535938f5fd3501">operator=</a> (std::initializer_list&lt; <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &gt; il)</td></tr>
<tr class="memdesc:ab777be375a9d249931535938f5fd3501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list operator= (C++11)  <a href="#ab777be375a9d249931535938f5fd3501">More...</a><br/></td></tr>
<tr class="separator:ab777be375a9d249931535938f5fd3501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92154c0107dee3a60074379676ce84d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a92154c0107dee3a60074379676ce84d5">assign</a> (std::initializer_list&lt; <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &gt; il)</td></tr>
<tr class="memdesc:a92154c0107dee3a60074379676ce84d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign with initializer_list (C++11)  <a href="#a92154c0107dee3a60074379676ce84d5">More...</a><br/></td></tr>
<tr class="separator:a92154c0107dee3a60074379676ce84d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Others</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Functions not used in release version: debug, profile and compatibility. </p>
</div></td></tr>
<tr class="memitem:a06d09b223540e7ee92a788f0950d60ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a06d09b223540e7ee92a788f0950d60ed">__check_consistency</a> ()</td></tr>
<tr class="memdesc:a06d09b223540e7ee92a788f0950d60ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks consistency of the container (debug).  <a href="#a06d09b223540e7ee92a788f0950d60ed">More...</a><br/></td></tr>
<tr class="separator:a06d09b223540e7ee92a788f0950d60ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4a59c3983bb4e5beb895702fe541f8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2b4a59c3983bb4e5beb895702fe541f8"></a>
template&lt;class output_stream &gt; </td></tr>
<tr class="memitem:a2b4a59c3983bb4e5beb895702fe541f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a2b4a59c3983bb4e5beb895702fe541f8">__output</a> (output_stream &amp;o, const char *comm=&quot;&quot;)</td></tr>
<tr class="memdesc:a2b4a59c3983bb4e5beb895702fe541f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the contents of container into the stream (debug). <br/></td></tr>
<tr class="separator:a2b4a59c3983bb4e5beb895702fe541f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1438d2bb1bbb981a6bd629bd2b9e5ee8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1438d2bb1bbb981a6bd629bd2b9e5ee8"></a>
<a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a1438d2bb1bbb981a6bd629bd2b9e5ee8">__children_in_branch</a> ()</td></tr>
<tr class="memdesc:a1438d2bb1bbb981a6bd629bd2b9e5ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns L (second parameter of the template) (profile, RTTI). <br/></td></tr>
<tr class="separator:a1438d2bb1bbb981a6bd629bd2b9e5ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043487e2fc72957b8482ef74ba362ea1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a043487e2fc72957b8482ef74ba362ea1"></a>
<a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a043487e2fc72957b8482ef74ba362ea1">__elements_in_leaf</a> ()</td></tr>
<tr class="memdesc:a043487e2fc72957b8482ef74ba362ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns M (third parameter of the template) (profile, RTTI). <br/></td></tr>
<tr class="separator:a043487e2fc72957b8482ef74ba362ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ca4b17575482709824fa6536ebca1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5ca4b17575482709824fa6536ebca1e"></a>
<a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#ad5ca4b17575482709824fa6536ebca1e">__branch_size</a> ()</td></tr>
<tr class="memdesc:ad5ca4b17575482709824fa6536ebca1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns size of inner node of the tree (profile, RTTI). <br/></td></tr>
<tr class="separator:ad5ca4b17575482709824fa6536ebca1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838e214fc52a29dd1e14dbfe71a4c8c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a838e214fc52a29dd1e14dbfe71a4c8c4"></a>
<a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a838e214fc52a29dd1e14dbfe71a4c8c4">__leaf_size</a> ()</td></tr>
<tr class="memdesc:a838e214fc52a29dd1e14dbfe71a4c8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns size of leaf node of the tree (profile, RTTI). <br/></td></tr>
<tr class="separator:a838e214fc52a29dd1e14dbfe71a4c8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade132985747d70833960884e9e41d622"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade132985747d70833960884e9e41d622"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#ade132985747d70833960884e9e41d622">reserve</a> (<a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a> n)</td></tr>
<tr class="memdesc:ade132985747d70833960884e9e41d622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function does nothing (compatibility with std::vector). <br/></td></tr>
<tr class="separator:ade132985747d70833960884e9e41d622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a6c5f4455b09fe2c06120ae829d37b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73a6c5f4455b09fe2c06120ae829d37b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a73a6c5f4455b09fe2c06120ae829d37b">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a73a6c5f4455b09fe2c06120ae829d37b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function does nothing (compatibility with std::vector). <br/></td></tr>
<tr class="separator:a73a6c5f4455b09fe2c06120ae829d37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d1a655403270a1d736fea956c37c9d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81d1a655403270a1d736fea956c37c9d"></a>
<a class="el" href="classbtree__seq.html#aacabfb30eacb213d95f505e477308ad6">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtree__seq.html#a81d1a655403270a1d736fea956c37c9d">get_allocator</a> () const </td></tr>
<tr class="memdesc:a81d1a655403270a1d736fea956c37c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns allocator. <br/></td></tr>
<tr class="separator:a81d1a655403270a1d736fea956c37c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt;<br/>
class btree_seq&lt; T, L, M, A &gt;</h3>

<p>The fast sequence container, which behaves like std::vector takes O(log(N)) to insert/delete elements. </p>
<p>This container implements most of std::vector's members. It inserts/deletes elements much faster than any standart container. However, random access to the element takes O(log(N)) time as well. For sequential access to elements, iterators and <code> visit </code> exist, which require practically constant time per element. The implementation is based on btrees. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the element </td></tr>
    <tr><td class="paramname">L</td><td>maximal number of children per branch, default 30 minimum 4. You can change it for better performance. </td></tr>
    <tr><td class="paramname">M</td><td>maximal number of elements per leaf, default 60 minimum 4. You can change it for better performance. </td></tr>
    <tr><td class="paramname">A</td><td>allocator. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae967878d371222a4f9ade09a6f219ed7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::<a class="el" href="classbtree__seq.html">btree_seq</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtree__seq.html#aacabfb30eacb213d95f505e477308ad6">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classbtree__seq.html#aacabfb30eacb213d95f505e477308ad6">allocator_type</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty container constructor. </p>
<p>Constructs an empty container with no elements. Complexity: constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>allocator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf681c6f509bdf7ca1045797b77f9875"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::<a class="el" href="classbtree__seq.html">btree_seq</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Copies all elements from another container. Complexity: O(N*log(N)), N=that.size(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>another container to be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa778862dbb879f8d7ca5fa0a41b0d60e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::<a class="el" href="classbtree__seq.html">btree_seq</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtree__seq.html#aacabfb30eacb213d95f505e477308ad6">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classbtree__seq.html#aacabfb30eacb213d95f505e477308ad6">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill constructor. </p>
<p>Constructs a container with n elements, each of them is copy of val. Complexity: O(n*log(n)). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>number of elements </td></tr>
    <tr><td class="paramname">val</td><td>fill value </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad3e7278bb146819587794a2e4014f7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::<a class="el" href="classbtree__seq.html">btree_seq</a> </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtree__seq.html#aacabfb30eacb213d95f505e477308ad6">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classbtree__seq.html#aacabfb30eacb213d95f505e477308ad6">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Range constructor. </p>
<p>Constructs a container filled with elements from range [first,last). Complexity: O(N*log(N)), N=dist(last,first). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first position in a range </td></tr>
    <tr><td class="paramname">last</td><td>last position in a range </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aadb4e7d5b31301728c71cdc33eccf746"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::<a class="el" href="classbtree__seq.html">btree_seq</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>that</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtree__seq.html#aacabfb30eacb213d95f505e477308ad6">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classbtree__seq.html#aacabfb30eacb213d95f505e477308ad6">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor (C++11) </p>
<p>Creates a copy of container and leaves that container in valid (empty) state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>container to copy </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e4a61a64d5b3c9fae883ea8d6fb4492"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::<a class="el" href="classbtree__seq.html">btree_seq</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtree__seq.html#aacabfb30eacb213d95f505e477308ad6">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classbtree__seq.html#aacabfb30eacb213d95f505e477308ad6">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer list constructor (C++11) </p>
<p>Creates a container with elements in initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>initializer_list </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac566a0c4104292b7e9743aef345961a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::~<a class="el" href="classbtree__seq.html">btree_seq</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Deletes the contents and frees memory. Complexity: O(N*log(N)). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a06d09b223540e7ee92a788f0950d60ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::__check_consistency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks consistency of the container (debug). </p>
<p>Use this function when modifying this code or if you are unsure, if your program corrupts memory of the container. </p>

</div>
</div>
<a class="anchor" id="a9adbb4b43417a3e99de04e7a0fd18b71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the whole contents with n copies of val. </p>
<p>Erases contents of the container, then fills it with n copies of val. Complexity: O((n+M)*log(n+M)), M - existing elements, n - new ones </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>new size of container </td></tr>
    <tr><td class="paramname">val</td><td>element to clone </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeca3a97168136ca7a2bbe6b72928a41d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the whole contents with a range. </p>
<p>Erases contents of the container, then fills it with a copy of range [first,last). Complexity: O((n+M)*log(n+M)), M - existing elements, n - new ones </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first element to be inserted </td></tr>
    <tr><td class="paramname">last</td><td>element behind the last element to be inserted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92154c0107dee3a60074379676ce84d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>assign with initializer_list (C++11) </p>
<p>Replaces the contents with the values of initializer_list </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>new contents </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b7eae08cf84bfdc7171c54b86b7563d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#a56b3f48ea01641b185a7afb822a78c2f">reference</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to element with range check. </p>
<p>Returns a reference to the element at position pos. Complexity: O(log(N)). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>index of the element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a389fdef127cc151dd883193f977d74f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#a545810e07ddf342e97b8584eab786ae5">const_reference</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant access to element with range check. </p>
<p>Returns a constant reference to the element at position pos. Complexity: O(log(N)). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>index of the element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf48b8c30757da3a8634c3696aedec3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#a56b3f48ea01641b185a7afb822a78c2f">reference</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element. </p>
<p>Complexity: O(log(N)). </p>

</div>
</div>
<a class="anchor" id="a2cda219eca79d5b1697f58ef68acafb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#a545810e07ddf342e97b8584eab786ae5">const_reference</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the last element. </p>
<p>Complexity: O(log(N)). </p>

</div>
</div>
<a class="anchor" id="a2cbaddcbced2e577422a3bcc961c7809"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return constant iterator to beginning. </p>
<p>Complexity: constant. </p>

</div>
</div>
<a class="anchor" id="abcaa2fdbe4894061cf565c6fa49d9f7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#ac2f5b004a113fda8832babbac5215871">iterator</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return iterator to beginning. </p>
<p>Complexity: constant. </p>

</div>
</div>
<a class="anchor" id="a3460dd0210953edc353d4238ded53b4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return constant iterator to beginning. </p>
<p>Complexity: constant. </p>

</div>
</div>
<a class="anchor" id="adec771bf973f3b9bff318bbb17f55ee2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return constant iterator to end. </p>
<p>Complexity: constant. </p>

</div>
</div>
<a class="anchor" id="a00ccc92fa4872337b82d0953e0342111"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::citerator_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return constant iterator to a given index. </p>
<p>Complexity: constant. </p>

</div>
</div>
<a class="anchor" id="a4825047ccfa73bf0463adf140686572a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all contents of the container. </p>
<p>Complexity: O(N*log(N)) </p>

</div>
</div>
<a class="anchor" id="a552b7737567dc43f66ec8a84acdf98b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::concatenate_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast concatenate two sequences (that sequence to the left). </p>
<p>Concatenate two sequences (that sequence to the left), put result into this sequence and leave that sequence empty. Concatenation is done without copying all elements. Example: if sequence A contains {0,1,2} and sequeance B contains {3,4,5}, after a call 'A.concatenate_left(B)' A contains {3,4,5,0,1,2} and B is empty. Complexity: O(log(N+M)) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>container to concatenate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a920653703ae3ba03593844b5098cc2ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::concatenate_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast concatenate two sequences (that sequence to the right). </p>
<p>Concatenate two sequences (that sequence to the right), put result into this sequence and leave that sequence empty. Concatenation is done without copying all elements. Example: if sequence A contains {0,1,2} and sequeance B contains {3,4,5}, after a call 'A.concatenate_right(B)' A contains {0,1,2,3,4,5} and B is empty. Complexity: O(log(N+M)) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>container to concatenate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6f43e0675ba88f9837e94098c3057fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#a3a48111ade15f99ba6de79c6def32372">const_reverse_iterator</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return constant reverse iterator to reverse beginning. </p>
<p>Complexity: constant. </p>

</div>
</div>
<a class="anchor" id="a25094ad31605b20365bd5de66f6d6738"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#a3a48111ade15f99ba6de79c6def32372">const_reverse_iterator</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return constant reverse iterator to reverse end. </p>
<p>Complexity: constant. </p>

</div>
</div>
<a class="anchor" id="a9acc9d2f9612ae243046ffeebe9e4271"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Native emplace function (C++11) </p>
<p>Constructs an element using args and places it to the given position </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position to create element </td></tr>
    <tr><td class="paramname">args</td><td>parameters passed to element's constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f95eb47da57937f68d459481ba69a27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#ac2f5b004a113fda8832babbac5215871">iterator</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an element at the given position (C++11) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position to place new element </td></tr>
    <tr><td class="paramname">args</td><td>arguments passed to the element's constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the new element </dd></dl>

</div>
</div>
<a class="anchor" id="a4a7dcb91cb32f14a8a15cf4954d0b8ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return constant iterator to end. </p>
<p>Complexity: constant. </p>

</div>
</div>
<a class="anchor" id="adf6364a7d2560e00253f860ffd9631ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#ac2f5b004a113fda8832babbac5215871">iterator</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return constant iterator to end. </p>
<p>Complexity: constant. </p>

</div>
</div>
<a class="anchor" id="ad1f93ea67380237bf705c78bcf2cae98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Native function for erasing elements. </p>
<p>Erase the range of [first,last) elements. Complexity: O(M*log(N)), M-erased elements, N - all elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>index of the first element to erase </td></tr>
    <tr><td class="paramname">last</td><td>index of the last element to erase + 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea9c10fd4ec46c7f13939b7d9cdd10f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#ac2f5b004a113fda8832babbac5215871">iterator</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compatible function for erasing one element. </p>
<p>Erase the element at position pos. Complexity: O(log(N)). Hint: native '<a class="el" href="classbtree__seq.html#ad1f93ea67380237bf705c78bcf2cae98" title="Native function for erasing elements. ">erase(size_type, size_type)</a>' might be faster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>index of the element to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the next position after erased element </dd></dl>

</div>
</div>
<a class="anchor" id="a0f6cb6609f7fd9866d267ec8bbaa7b5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#ac2f5b004a113fda8832babbac5215871">iterator</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compatible function for erasing elements. </p>
<p>Erase the range of [first,last) elements. Complexity: O(M*log(N)), M-erased elements, N - all elements. Hint: native '<a class="el" href="classbtree__seq.html#ad1f93ea67380237bf705c78bcf2cae98" title="Native function for erasing elements. ">erase(size_type, size_type)</a>' might be faster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>index of the first element to erase </td></tr>
    <tr><td class="paramname">last</td><td>index of the last element to erase + 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the next position after erased elements </dd></dl>

</div>
</div>
<a class="anchor" id="a239c4dd4465685efc9661cc932f8c5d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td>
          <td class="paramname"><em>repetition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Native function for inserting n copies of an element. </p>
<p>Inserts n copiesof an element at a given position. Complexity: O((n+M)*log(n+M)), M - existing elements, n - new ones. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position to insert </td></tr>
    <tr><td class="paramname">repetition</td><td>number of copies to insert </td></tr>
    <tr><td class="paramname">val</td><td>value to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ffe3f8e12e9910dd5d505d2220cfc68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#a56b3f48ea01641b185a7afb822a78c2f">reference</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element. </p>
<p>Complexity: O(log(N)). </p>

</div>
</div>
<a class="anchor" id="ada29272e15728d63e8f0ae7b3b08f6f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#a545810e07ddf342e97b8584eab786ae5">const_reference</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constnt reference to the first element. </p>
<p>Complexity: O(log(N)). </p>

</div>
</div>
<a class="anchor" id="ac646ad8ff84bdd504f4650e9cc365724"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Native function for inserting a single element. </p>
<p>Inserts the element at given position. Hint: inserting the range is faster then multiple insertions of one element. Complexity: O(log(N)). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position to insert </td></tr>
    <tr><td class="paramname">val</td><td>element to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adfb71f46140eb692007294fecea3ab65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Native function for inserting a range of elements. </p>
<p>Inserts the range [first,last) of elements into the given position. Complexity: O((N+M)*log(N+M)), N-existing elements, M - new ones. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position to insert </td></tr>
    <tr><td class="paramname">first</td><td>first element to insert </td></tr>
    <tr><td class="paramname">last</td><td>element behind the last element to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af01165cb27da14f4a8108f0f458c255d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#ac2f5b004a113fda8832babbac5215871">iterator</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compatible function for inserting the single element. </p>
<p>Inserts a single element at a given position. Complexity: O((N+M)*log(N+M)), N-existing elements, M - new ones. Hint: native '<a class="el" href="classbtree__seq.html#ac646ad8ff84bdd504f4650e9cc365724" title="Native function for inserting a single element. ">insert(size_type, const value_type&amp; t)</a>' might be faster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position to insert </td></tr>
    <tr><td class="paramname">val</td><td>value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the newly inserted element </dd></dl>

</div>
</div>
<a class="anchor" id="a441c12c08c25c9b90c064607aea8ea60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#ac2f5b004a113fda8832babbac5215871">iterator</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compatible function for inserting n copies of an element. </p>
<p>Inserts n copiesof an element at a given position. Complexity: O((n+M)*log(n+M)), M - existing elements, n - new ones. Hint: native '<a class="el" href="classbtree__seq.html#a239c4dd4465685efc9661cc932f8c5d7" title="Native function for inserting n copies of an element. ">fill(size_type, size_type, const value_type&amp; val)</a>' might be faster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position to insert </td></tr>
    <tr><td class="paramname">n</td><td>number of copies to insert </td></tr>
    <tr><td class="paramname">val</td><td>value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the first of newly inserted elements </dd></dl>

</div>
</div>
<a class="anchor" id="a74ba52ae106966fe8244efb41f573279"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#ac2f5b004a113fda8832babbac5215871">iterator</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compatible function for inserting a range of elements. </p>
<p>Inserts the range [first,last) of elements into the given position. Complexity: O((N+M)*log(N+M)), N-existing elements, M - new ones. Hint: native '<a class="el" href="classbtree__seq.html#adfb71f46140eb692007294fecea3ab65" title="Native function for inserting a range of elements. ">insert(size_type, InputIterator, InputIterator)</a>' might be faster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position to insert </td></tr>
    <tr><td class="paramname">first</td><td>first element to insert </td></tr>
    <tr><td class="paramname">last</td><td>element behind the last element to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the first of newly inserted elements </dd></dl>

</div>
</div>
<a class="anchor" id="af04cc444213c48f2bb2da568b287d869"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Native inserting of rvalue (C++11) </p>
<p>Moves the value into the given position and leaves old value undefined but valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position where the value is inserted </td></tr>
    <tr><td class="paramname">val</td><td>the object to be moved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a606ee33665104f91de1d74be4d68a848"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#ac2f5b004a113fda8832babbac5215871">iterator</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compatible insertion of rvalue (C++11) </p>
<p>Moves the value into the given position and leaves old value undefined, but valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position where the value is inserted </td></tr>
    <tr><td class="paramname">val</td><td>the object to be moved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the new inserted value </dd></dl>

</div>
</div>
<a class="anchor" id="a643109fc4a01c8a6524f3a274980b6d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Native inserting of elements using initializer_list (C++11) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>place to insert </td></tr>
    <tr><td class="paramname">il</td><td>elements to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99eb3c396aa2246d62fd65d83f8979a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#ac2f5b004a113fda8832babbac5215871">iterator</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#a92a13523f3cb23d63b45b2a9439bbc64">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compatible inserting of elements using initializer_list (C++11) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>place to insert </td></tr>
    <tr><td class="paramname">il</td><td>elements to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the first of new inserted values </dd></dl>

</div>
</div>
<a class="anchor" id="ad0b13b712a26d216a5392ae16289d073"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#ac2f5b004a113fda8832babbac5215871">iterator</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::iterator_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return iterator to a given index. </p>
<p>Complexity: constant. </p>

</div>
</div>
<a class="anchor" id="a77f2e899303623fa3ee7cabeb685664d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html">btree_seq</a>&amp; <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign content. </p>
<p>Deletes old contents and replaces it with copy of contents of that. Complexity: O(N*log(N))+O(M*log(M)), N=this-&gt;<a class="el" href="classbtree__seq.html#a7718a31872ee32e50c6bc27bafc70c7b" title="Number of elements in container. ">size()</a>, M=that.size(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>container to be assigned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adb8a35aee8a011f4e699887210e364f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html">btree_seq</a>&amp; <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move operator= (C++11) </p>
<p>Creates a copy and leaves that container in empty state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>container to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab777be375a9d249931535938f5fd3501"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html">btree_seq</a>&amp; <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer list operator= (C++11) </p>
<p>Replaces the contents with the values of initializer_list </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>new contents </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4fc5026ae6f80c7e6f5d2a4251638e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#a56b3f48ea01641b185a7afb822a78c2f">reference</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to element. </p>
<p>Returns a reference to the element at position pos. No range check is done. Complexity: O(log(N)). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>index of the element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a953676ab63917fe656a55946d52569e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#a545810e07ddf342e97b8584eab786ae5">const_reference</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant access to element. </p>
<p>Returns a constant reference to the element at position pos. No range check is done. Complexity: O(log(N)). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>index of the element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8ab6029eac58ff440c34507eeb83788a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last element. </p>
<p>Complexity: O(log(N)) </p>

</div>
</div>
<a class="anchor" id="a848a059b91c3099306e72bbafcb44e20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the first element. </p>
<p>Complexity: O(log(N)) </p>

</div>
</div>
<a class="anchor" id="a129e0dfc0071f0856043cd0c63e0a31e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds element to the end of the sequence. </p>
<p>Complexity: O(log(N)) </p>

</div>
</div>
<a class="anchor" id="a198c1d96d898ef3e7e9704e07c6400bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds element to the beginning of the sequence. </p>
<p>Complexity: O(log(N)) </p>

</div>
</div>
<a class="anchor" id="ac97d9590209db423c1894ede620c02b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#a3a48111ade15f99ba6de79c6def32372">const_reverse_iterator</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return constant reverse iterator to reverse beginning. </p>
<p>Complexity: constant. </p>

</div>
</div>
<a class="anchor" id="a3ade4d8fb4dc24794fc8ca0a6b997941"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#a112f455474f3f89b194a473a8895eff3">reverse_iterator</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return reverse iterator to reverse beginning. </p>
<p>Complexity: constant. </p>

</div>
</div>
<a class="anchor" id="afd6b6aeff69677b6284056787ef9eb8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#a3a48111ade15f99ba6de79c6def32372">const_reverse_iterator</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return constant reverse iterator to reverse end. </p>
<p>Complexity: constant. </p>

</div>
</div>
<a class="anchor" id="ac2175c21e53e7ec96bf149eefd601c8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#a112f455474f3f89b194a473a8895eff3">reverse_iterator</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return reverse iterator to reverse end. </p>
<p>Complexity: constant. </p>

</div>
</div>
<a class="anchor" id="ae0ca414d95bfdfe1991e4d233a1eab5b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em> = <code><a class="el" href="classbtree__seq.html#a2795ed69e57bfb546fedff03f0c53d18">value_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize container so that it contains n elements. </p>
<p>If n is greater than container size, copies of the val are added to the end. If n is less than container size, some elements at the end of container are deleted. </p>

</div>
</div>
<a class="anchor" id="abb0100fa5afe5ff6d475cb31bfef5b63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::split_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>that</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast split, leaving left piece in that container. </p>
<p>Split sequence into two parts: [pos,size) is left in this container, [0,pos) is moved to that container. That container is cleaned before operation. Example if A contained {0,1,2,3,4}, after A.split_left(B,3) A contains {3,4} and B contains {0,1,2}. The operation is done without moving all elements. Complexity: O(log(N)), if the second container is initially empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>container for leftt part of split operation (old contents removed) </td></tr>
    <tr><td class="paramname">pos</td><td>place to split </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a93b2ff28f3722f18b09b8d0e3852efc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::split_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>that</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast split, leaving right piece in that container. </p>
<p>Split sequence into two parts: [0,pos) is left in this container, [pos,size) is moved to that container. That container is cleaned before operation. Example if A contained {0,1,2,3,4}, after A.split_right(B,3) A contains {0,1,2} and B contains {3,4}. The operation is done without moving all elements. Complexity: O(log(N)), if the second container is initially empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>container for right part of split operation (old contents removed) </td></tr>
    <tr><td class="paramname">pos</td><td>place to split </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a619807093d367c8b0597929bfd4c3ba3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps contents of two containers. </p>
<p>Complexity: constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>container to swap with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3386347d804526a1e8e5b83dbf7bb234"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int L = 30, int M = 60, typename A = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a> <a class="el" href="classbtree__seq.html">btree_seq</a>&lt; T, L, M, A &gt;::visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtree__seq.html#ac5483ae7c750d2e6391e5fec12e4f67e">size_type</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sequential search/modify operation on the range. </p>
<p>Implements visitor pattern. The function 'visit' calls v() on the elements in the given range sequentially, until the end of range is reached or v() returns true (whichever happens earlier). This function allows to implement patterns like find_if, for_each and so on, but it behaves significantly (roughly twice) faster than standard implementation and iterator access. Complexity: O(log(N)*(end-start)) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first element on which visitor should be called </td></tr>
    <tr><td class="paramname">last</td><td>the element beyond the last element on which visitor should be called </td></tr>
    <tr><td class="paramname">v</td><td>the visitor class, which must have 'bool operator(element&amp;)' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the first element when v() returned true, or end if v() never returned true </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="btree__seq_8h_source.html">btree_seq.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
